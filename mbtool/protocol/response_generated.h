// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_
#define FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_

#include "flatbuffers/flatbuffers.h"

#include "crypto_decrypt_generated.h"
#include "crypto_get_pw_type_generated.h"
#include "file_chmod_generated.h"
#include "file_close_generated.h"
#include "file_open_generated.h"
#include "file_read_generated.h"
#include "file_seek_generated.h"
#include "file_selinux_get_label_generated.h"
#include "file_selinux_set_label_generated.h"
#include "file_stat_generated.h"
#include "file_write_generated.h"
#include "mb_get_booted_rom_id_generated.h"
#include "mb_get_installed_roms_generated.h"
#include "mb_get_packages_count_generated.h"
#include "mb_get_version_generated.h"
#include "mb_set_kernel_generated.h"
#include "mb_switch_rom_generated.h"
#include "mb_wipe_rom_generated.h"
#include "path_chmod_generated.h"
#include "path_copy_generated.h"
#include "path_delete_generated.h"
#include "path_get_directory_size_generated.h"
#include "path_mkdir_generated.h"
#include "path_selinux_get_label_generated.h"
#include "path_selinux_set_label_generated.h"
#include "reboot_generated.h"
#include "shutdown_generated.h"
#include "signed_exec_generated.h"

namespace mbtool {
namespace daemon {
namespace v3 {
struct CryptoDecryptRequest;
struct CryptoDecryptResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct CryptoGetPwTypeRequest;
struct CryptoGetPwTypeResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileChmodRequest;
struct FileChmodResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileCloseRequest;
struct FileCloseResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileOpenRequest;
struct FileOpenResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileReadRequest;
struct FileReadResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileSeekRequest;
struct FileSeekResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct StructStat;
struct FileStatRequest;
struct FileStatResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileWriteRequest;
struct FileWriteResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileSELinuxGetLabelRequest;
struct FileSELinuxGetLabelResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct FileSELinuxSetLabelRequest;
struct FileSELinuxSetLabelResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct PathChmodRequest;
struct PathChmodResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct PathCopyRequest;
struct PathCopyResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct PathDeleteRequest;
struct PathDeleteResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct PathMkdirRequest;
struct PathMkdirResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct PathSELinuxGetLabelRequest;
struct PathSELinuxGetLabelResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct PathSELinuxSetLabelRequest;
struct PathSELinuxSetLabelResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct PathGetDirectorySizeRequest;
struct PathGetDirectorySizeResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct SignedExecRequest;
struct SignedExecOutputResponse;
struct SignedExecResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct MbGetVersionRequest;
struct MbGetVersionResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct MbRom;
struct MbGetInstalledRomsRequest;
struct MbGetInstalledRomsResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct MbGetBootedRomIdRequest;
struct MbGetBootedRomIdResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct MbSwitchRomRequest;
struct MbSwitchRomResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct MbSetKernelRequest;
struct MbSetKernelResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct MbWipeRomRequest;
struct MbWipeRomResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct MbGetPackagesCountRequest;
struct MbGetPackagesCountResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct RebootRequest;
struct RebootResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool
namespace mbtool {
namespace daemon {
namespace v3 {
struct ShutdownRequest;
struct ShutdownResponse;
}  // namespace v3
}  // namespace daemon
}  // namespace mbtool

namespace mbtool {
namespace daemon {
namespace v3 {

struct Invalid;
struct Unsupported;
struct Response;

enum ResponseType {
  ResponseType_NONE = 0,
  ResponseType_Invalid = 1,
  ResponseType_Unsupported = 2,
  ResponseType_FileChmodResponse = 3,
  ResponseType_FileCloseResponse = 4,
  ResponseType_FileOpenResponse = 5,
  ResponseType_FileReadResponse = 6,
  ResponseType_FileSeekResponse = 7,
  ResponseType_FileStatResponse = 8,
  ResponseType_FileWriteResponse = 9,
  ResponseType_FileSELinuxGetLabelResponse = 10,
  ResponseType_FileSELinuxSetLabelResponse = 11,
  ResponseType_PathChmodResponse = 12,
  ResponseType_PathCopyResponse = 13,
  ResponseType_PathSELinuxGetLabelResponse = 14,
  ResponseType_PathSELinuxSetLabelResponse = 15,
  ResponseType_PathGetDirectorySizeResponse = 16,
  ResponseType_MbGetVersionResponse = 17,
  ResponseType_MbGetInstalledRomsResponse = 18,
  ResponseType_MbGetBootedRomIdResponse = 19,
  ResponseType_MbSwitchRomResponse = 20,
  ResponseType_MbSetKernelResponse = 21,
  ResponseType_MbWipeRomResponse = 22,
  ResponseType_MbGetPackagesCountResponse = 23,
  ResponseType_RebootResponse = 24,
  ResponseType_SignedExecOutputResponse = 25,
  ResponseType_SignedExecResponse = 26,
  ResponseType_ShutdownResponse = 27,
  ResponseType_PathDeleteResponse = 28,
  ResponseType_PathMkdirResponse = 29,
  ResponseType_CryptoDecryptResponse = 30,
  ResponseType_CryptoGetPwTypeResponse = 31,
  ResponseType_MIN = ResponseType_NONE,
  ResponseType_MAX = ResponseType_CryptoGetPwTypeResponse
};

inline const char **EnumNamesResponseType() {
  static const char *names[] = { "NONE", "Invalid", "Unsupported", "FileChmodResponse", "FileCloseResponse", "FileOpenResponse", "FileReadResponse", "FileSeekResponse", "FileStatResponse", "FileWriteResponse", "FileSELinuxGetLabelResponse", "FileSELinuxSetLabelResponse", "PathChmodResponse", "PathCopyResponse", "PathSELinuxGetLabelResponse", "PathSELinuxSetLabelResponse", "PathGetDirectorySizeResponse", "MbGetVersionResponse", "MbGetInstalledRomsResponse", "MbGetBootedRomIdResponse", "MbSwitchRomResponse", "MbSetKernelResponse", "MbWipeRomResponse", "MbGetPackagesCountResponse", "RebootResponse", "SignedExecOutputResponse", "SignedExecResponse", "ShutdownResponse", "PathDeleteResponse", "PathMkdirResponse", "CryptoDecryptResponse", "CryptoGetPwTypeResponse", nullptr };
  return names;
}

inline const char *EnumNameResponseType(ResponseType e) { return EnumNamesResponseType()[static_cast<int>(e)]; }

inline bool VerifyResponseType(flatbuffers::Verifier &verifier, const void *union_obj, ResponseType type);

struct Invalid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InvalidBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  InvalidBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  InvalidBuilder &operator=(const InvalidBuilder &);
  flatbuffers::Offset<Invalid> Finish() {
    auto o = flatbuffers::Offset<Invalid>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<Invalid> CreateInvalid(flatbuffers::FlatBufferBuilder &_fbb) {
  InvalidBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Unsupported FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnsupportedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  UnsupportedBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UnsupportedBuilder &operator=(const UnsupportedBuilder &);
  flatbuffers::Offset<Unsupported> Finish() {
    auto o = flatbuffers::Offset<Unsupported>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<Unsupported> CreateUnsupported(flatbuffers::FlatBufferBuilder &_fbb) {
  UnsupportedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  ResponseType response_type() const { return static_cast<ResponseType>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0)); }
  const void *response() const { return GetPointer<const void *>(VT_RESPONSE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RESPONSE) &&
           VerifyResponseType(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response_type(ResponseType response_type) { fbb_.AddElement<uint8_t>(Response::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0); }
  void add_response(flatbuffers::Offset<void> response) { fbb_.AddOffset(Response::VT_RESPONSE, response); }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    auto o = flatbuffers::Offset<Response>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(flatbuffers::FlatBufferBuilder &_fbb,
   ResponseType response_type = ResponseType_NONE,
   flatbuffers::Offset<void> response = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

inline bool VerifyResponseType(flatbuffers::Verifier &verifier, const void *union_obj, ResponseType type) {
  switch (type) {
    case ResponseType_NONE: return true;
    case ResponseType_Invalid: return verifier.VerifyTable(reinterpret_cast<const Invalid *>(union_obj));
    case ResponseType_Unsupported: return verifier.VerifyTable(reinterpret_cast<const Unsupported *>(union_obj));
    case ResponseType_FileChmodResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileChmodResponse *>(union_obj));
    case ResponseType_FileCloseResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileCloseResponse *>(union_obj));
    case ResponseType_FileOpenResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileOpenResponse *>(union_obj));
    case ResponseType_FileReadResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileReadResponse *>(union_obj));
    case ResponseType_FileSeekResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileSeekResponse *>(union_obj));
    case ResponseType_FileStatResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileStatResponse *>(union_obj));
    case ResponseType_FileWriteResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileWriteResponse *>(union_obj));
    case ResponseType_FileSELinuxGetLabelResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileSELinuxGetLabelResponse *>(union_obj));
    case ResponseType_FileSELinuxSetLabelResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::FileSELinuxSetLabelResponse *>(union_obj));
    case ResponseType_PathChmodResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::PathChmodResponse *>(union_obj));
    case ResponseType_PathCopyResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::PathCopyResponse *>(union_obj));
    case ResponseType_PathSELinuxGetLabelResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::PathSELinuxGetLabelResponse *>(union_obj));
    case ResponseType_PathSELinuxSetLabelResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::PathSELinuxSetLabelResponse *>(union_obj));
    case ResponseType_PathGetDirectorySizeResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::PathGetDirectorySizeResponse *>(union_obj));
    case ResponseType_MbGetVersionResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::MbGetVersionResponse *>(union_obj));
    case ResponseType_MbGetInstalledRomsResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::MbGetInstalledRomsResponse *>(union_obj));
    case ResponseType_MbGetBootedRomIdResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::MbGetBootedRomIdResponse *>(union_obj));
    case ResponseType_MbSwitchRomResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::MbSwitchRomResponse *>(union_obj));
    case ResponseType_MbSetKernelResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::MbSetKernelResponse *>(union_obj));
    case ResponseType_MbWipeRomResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::MbWipeRomResponse *>(union_obj));
    case ResponseType_MbGetPackagesCountResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::MbGetPackagesCountResponse *>(union_obj));
    case ResponseType_RebootResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::RebootResponse *>(union_obj));
    case ResponseType_SignedExecOutputResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::SignedExecOutputResponse *>(union_obj));
    case ResponseType_SignedExecResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::SignedExecResponse *>(union_obj));
    case ResponseType_ShutdownResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::ShutdownResponse *>(union_obj));
    case ResponseType_PathDeleteResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::PathDeleteResponse *>(union_obj));
    case ResponseType_PathMkdirResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::PathMkdirResponse *>(union_obj));
    case ResponseType_CryptoDecryptResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::CryptoDecryptResponse *>(union_obj));
    case ResponseType_CryptoGetPwTypeResponse: return verifier.VerifyTable(reinterpret_cast<const mbtool::daemon::v3::CryptoGetPwTypeResponse *>(union_obj));
    default: return false;
  }
}

inline const mbtool::daemon::v3::Response *GetResponse(const void *buf) { return flatbuffers::GetRoot<mbtool::daemon::v3::Response>(buf); }

inline bool VerifyResponseBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<mbtool::daemon::v3::Response>(); }

inline void FinishResponseBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<mbtool::daemon::v3::Response> root) { fbb.Finish(root); }

}  // namespace v3
}  // namespace daemon
}  // namespace mbtool

#endif  // FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_
