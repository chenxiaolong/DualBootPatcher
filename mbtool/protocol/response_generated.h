// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_
#define FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_

#include "flatbuffers/flatbuffers.h"

#include "crypto_decrypt_generated.h"
#include "crypto_get_pw_type_generated.h"
#include "file_chmod_generated.h"
#include "file_close_generated.h"
#include "file_open_generated.h"
#include "file_read_generated.h"
#include "file_seek_generated.h"
#include "file_selinux_get_label_generated.h"
#include "file_selinux_set_label_generated.h"
#include "file_stat_generated.h"
#include "file_write_generated.h"
#include "mb_get_booted_rom_id_generated.h"
#include "mb_get_installed_roms_generated.h"
#include "mb_get_packages_count_generated.h"
#include "mb_get_version_generated.h"
#include "mb_set_kernel_generated.h"
#include "mb_switch_rom_generated.h"
#include "mb_wipe_rom_generated.h"
#include "path_chmod_generated.h"
#include "path_copy_generated.h"
#include "path_delete_generated.h"
#include "path_get_directory_size_generated.h"
#include "path_mkdir_generated.h"
#include "path_readlink_generated.h"
#include "path_selinux_get_label_generated.h"
#include "path_selinux_set_label_generated.h"
#include "reboot_generated.h"
#include "shutdown_generated.h"
#include "signed_exec_generated.h"

namespace mbtool {
namespace daemon {
namespace v3 {

struct Invalid;

struct Unsupported;

struct Response;

enum ResponseType {
  ResponseType_NONE = 0,
  ResponseType_Invalid = 1,
  ResponseType_Unsupported = 2,
  ResponseType_FileChmodResponse = 3,
  ResponseType_FileCloseResponse = 4,
  ResponseType_FileOpenResponse = 5,
  ResponseType_FileReadResponse = 6,
  ResponseType_FileSeekResponse = 7,
  ResponseType_FileStatResponse = 8,
  ResponseType_FileWriteResponse = 9,
  ResponseType_FileSELinuxGetLabelResponse = 10,
  ResponseType_FileSELinuxSetLabelResponse = 11,
  ResponseType_PathChmodResponse = 12,
  ResponseType_PathCopyResponse = 13,
  ResponseType_PathSELinuxGetLabelResponse = 14,
  ResponseType_PathSELinuxSetLabelResponse = 15,
  ResponseType_PathGetDirectorySizeResponse = 16,
  ResponseType_MbGetVersionResponse = 17,
  ResponseType_MbGetInstalledRomsResponse = 18,
  ResponseType_MbGetBootedRomIdResponse = 19,
  ResponseType_MbSwitchRomResponse = 20,
  ResponseType_MbSetKernelResponse = 21,
  ResponseType_MbWipeRomResponse = 22,
  ResponseType_MbGetPackagesCountResponse = 23,
  ResponseType_RebootResponse = 24,
  ResponseType_SignedExecOutputResponse = 25,
  ResponseType_SignedExecResponse = 26,
  ResponseType_ShutdownResponse = 27,
  ResponseType_PathDeleteResponse = 28,
  ResponseType_PathMkdirResponse = 29,
  ResponseType_CryptoDecryptResponse = 30,
  ResponseType_CryptoGetPwTypeResponse = 31,
  ResponseType_PathReadlinkResponse = 32,
  ResponseType_MIN = ResponseType_NONE,
  ResponseType_MAX = ResponseType_PathReadlinkResponse
};

inline ResponseType (&EnumValuesResponseType())[33] {
  static ResponseType values[] = {
    ResponseType_NONE,
    ResponseType_Invalid,
    ResponseType_Unsupported,
    ResponseType_FileChmodResponse,
    ResponseType_FileCloseResponse,
    ResponseType_FileOpenResponse,
    ResponseType_FileReadResponse,
    ResponseType_FileSeekResponse,
    ResponseType_FileStatResponse,
    ResponseType_FileWriteResponse,
    ResponseType_FileSELinuxGetLabelResponse,
    ResponseType_FileSELinuxSetLabelResponse,
    ResponseType_PathChmodResponse,
    ResponseType_PathCopyResponse,
    ResponseType_PathSELinuxGetLabelResponse,
    ResponseType_PathSELinuxSetLabelResponse,
    ResponseType_PathGetDirectorySizeResponse,
    ResponseType_MbGetVersionResponse,
    ResponseType_MbGetInstalledRomsResponse,
    ResponseType_MbGetBootedRomIdResponse,
    ResponseType_MbSwitchRomResponse,
    ResponseType_MbSetKernelResponse,
    ResponseType_MbWipeRomResponse,
    ResponseType_MbGetPackagesCountResponse,
    ResponseType_RebootResponse,
    ResponseType_SignedExecOutputResponse,
    ResponseType_SignedExecResponse,
    ResponseType_ShutdownResponse,
    ResponseType_PathDeleteResponse,
    ResponseType_PathMkdirResponse,
    ResponseType_CryptoDecryptResponse,
    ResponseType_CryptoGetPwTypeResponse,
    ResponseType_PathReadlinkResponse
  };
  return values;
}

inline const char **EnumNamesResponseType() {
  static const char *names[] = {
    "NONE",
    "Invalid",
    "Unsupported",
    "FileChmodResponse",
    "FileCloseResponse",
    "FileOpenResponse",
    "FileReadResponse",
    "FileSeekResponse",
    "FileStatResponse",
    "FileWriteResponse",
    "FileSELinuxGetLabelResponse",
    "FileSELinuxSetLabelResponse",
    "PathChmodResponse",
    "PathCopyResponse",
    "PathSELinuxGetLabelResponse",
    "PathSELinuxSetLabelResponse",
    "PathGetDirectorySizeResponse",
    "MbGetVersionResponse",
    "MbGetInstalledRomsResponse",
    "MbGetBootedRomIdResponse",
    "MbSwitchRomResponse",
    "MbSetKernelResponse",
    "MbWipeRomResponse",
    "MbGetPackagesCountResponse",
    "RebootResponse",
    "SignedExecOutputResponse",
    "SignedExecResponse",
    "ShutdownResponse",
    "PathDeleteResponse",
    "PathMkdirResponse",
    "CryptoDecryptResponse",
    "CryptoGetPwTypeResponse",
    "PathReadlinkResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseType(ResponseType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResponseType()[index];
}

template<typename T> struct ResponseTypeTraits {
  static const ResponseType enum_value = ResponseType_NONE;
};

template<> struct ResponseTypeTraits<Invalid> {
  static const ResponseType enum_value = ResponseType_Invalid;
};

template<> struct ResponseTypeTraits<Unsupported> {
  static const ResponseType enum_value = ResponseType_Unsupported;
};

template<> struct ResponseTypeTraits<FileChmodResponse> {
  static const ResponseType enum_value = ResponseType_FileChmodResponse;
};

template<> struct ResponseTypeTraits<FileCloseResponse> {
  static const ResponseType enum_value = ResponseType_FileCloseResponse;
};

template<> struct ResponseTypeTraits<FileOpenResponse> {
  static const ResponseType enum_value = ResponseType_FileOpenResponse;
};

template<> struct ResponseTypeTraits<FileReadResponse> {
  static const ResponseType enum_value = ResponseType_FileReadResponse;
};

template<> struct ResponseTypeTraits<FileSeekResponse> {
  static const ResponseType enum_value = ResponseType_FileSeekResponse;
};

template<> struct ResponseTypeTraits<FileStatResponse> {
  static const ResponseType enum_value = ResponseType_FileStatResponse;
};

template<> struct ResponseTypeTraits<FileWriteResponse> {
  static const ResponseType enum_value = ResponseType_FileWriteResponse;
};

template<> struct ResponseTypeTraits<FileSELinuxGetLabelResponse> {
  static const ResponseType enum_value = ResponseType_FileSELinuxGetLabelResponse;
};

template<> struct ResponseTypeTraits<FileSELinuxSetLabelResponse> {
  static const ResponseType enum_value = ResponseType_FileSELinuxSetLabelResponse;
};

template<> struct ResponseTypeTraits<PathChmodResponse> {
  static const ResponseType enum_value = ResponseType_PathChmodResponse;
};

template<> struct ResponseTypeTraits<PathCopyResponse> {
  static const ResponseType enum_value = ResponseType_PathCopyResponse;
};

template<> struct ResponseTypeTraits<PathSELinuxGetLabelResponse> {
  static const ResponseType enum_value = ResponseType_PathSELinuxGetLabelResponse;
};

template<> struct ResponseTypeTraits<PathSELinuxSetLabelResponse> {
  static const ResponseType enum_value = ResponseType_PathSELinuxSetLabelResponse;
};

template<> struct ResponseTypeTraits<PathGetDirectorySizeResponse> {
  static const ResponseType enum_value = ResponseType_PathGetDirectorySizeResponse;
};

template<> struct ResponseTypeTraits<MbGetVersionResponse> {
  static const ResponseType enum_value = ResponseType_MbGetVersionResponse;
};

template<> struct ResponseTypeTraits<MbGetInstalledRomsResponse> {
  static const ResponseType enum_value = ResponseType_MbGetInstalledRomsResponse;
};

template<> struct ResponseTypeTraits<MbGetBootedRomIdResponse> {
  static const ResponseType enum_value = ResponseType_MbGetBootedRomIdResponse;
};

template<> struct ResponseTypeTraits<MbSwitchRomResponse> {
  static const ResponseType enum_value = ResponseType_MbSwitchRomResponse;
};

template<> struct ResponseTypeTraits<MbSetKernelResponse> {
  static const ResponseType enum_value = ResponseType_MbSetKernelResponse;
};

template<> struct ResponseTypeTraits<MbWipeRomResponse> {
  static const ResponseType enum_value = ResponseType_MbWipeRomResponse;
};

template<> struct ResponseTypeTraits<MbGetPackagesCountResponse> {
  static const ResponseType enum_value = ResponseType_MbGetPackagesCountResponse;
};

template<> struct ResponseTypeTraits<RebootResponse> {
  static const ResponseType enum_value = ResponseType_RebootResponse;
};

template<> struct ResponseTypeTraits<SignedExecOutputResponse> {
  static const ResponseType enum_value = ResponseType_SignedExecOutputResponse;
};

template<> struct ResponseTypeTraits<SignedExecResponse> {
  static const ResponseType enum_value = ResponseType_SignedExecResponse;
};

template<> struct ResponseTypeTraits<ShutdownResponse> {
  static const ResponseType enum_value = ResponseType_ShutdownResponse;
};

template<> struct ResponseTypeTraits<PathDeleteResponse> {
  static const ResponseType enum_value = ResponseType_PathDeleteResponse;
};

template<> struct ResponseTypeTraits<PathMkdirResponse> {
  static const ResponseType enum_value = ResponseType_PathMkdirResponse;
};

template<> struct ResponseTypeTraits<CryptoDecryptResponse> {
  static const ResponseType enum_value = ResponseType_CryptoDecryptResponse;
};

template<> struct ResponseTypeTraits<CryptoGetPwTypeResponse> {
  static const ResponseType enum_value = ResponseType_CryptoGetPwTypeResponse;
};

template<> struct ResponseTypeTraits<PathReadlinkResponse> {
  static const ResponseType enum_value = ResponseType_PathReadlinkResponse;
};

bool VerifyResponseType(flatbuffers::Verifier &verifier, const void *obj, ResponseType type);
bool VerifyResponseTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Invalid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InvalidBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InvalidBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InvalidBuilder &operator=(const InvalidBuilder &);
  flatbuffers::Offset<Invalid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Invalid>(end);
    return o;
  }
};

inline flatbuffers::Offset<Invalid> CreateInvalid(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InvalidBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Unsupported FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnsupportedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsupportedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsupportedBuilder &operator=(const UnsupportedBuilder &);
  flatbuffers::Offset<Unsupported> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unsupported>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unsupported> CreateUnsupported(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsupportedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  ResponseType response_type() const {
    return static_cast<ResponseType>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  template<typename T> const T *response_as() const;
  const Invalid *response_as_Invalid() const {
    return response_type() == ResponseType_Invalid ? static_cast<const Invalid *>(response()) : nullptr;
  }
  const Unsupported *response_as_Unsupported() const {
    return response_type() == ResponseType_Unsupported ? static_cast<const Unsupported *>(response()) : nullptr;
  }
  const FileChmodResponse *response_as_FileChmodResponse() const {
    return response_type() == ResponseType_FileChmodResponse ? static_cast<const FileChmodResponse *>(response()) : nullptr;
  }
  const FileCloseResponse *response_as_FileCloseResponse() const {
    return response_type() == ResponseType_FileCloseResponse ? static_cast<const FileCloseResponse *>(response()) : nullptr;
  }
  const FileOpenResponse *response_as_FileOpenResponse() const {
    return response_type() == ResponseType_FileOpenResponse ? static_cast<const FileOpenResponse *>(response()) : nullptr;
  }
  const FileReadResponse *response_as_FileReadResponse() const {
    return response_type() == ResponseType_FileReadResponse ? static_cast<const FileReadResponse *>(response()) : nullptr;
  }
  const FileSeekResponse *response_as_FileSeekResponse() const {
    return response_type() == ResponseType_FileSeekResponse ? static_cast<const FileSeekResponse *>(response()) : nullptr;
  }
  const FileStatResponse *response_as_FileStatResponse() const {
    return response_type() == ResponseType_FileStatResponse ? static_cast<const FileStatResponse *>(response()) : nullptr;
  }
  const FileWriteResponse *response_as_FileWriteResponse() const {
    return response_type() == ResponseType_FileWriteResponse ? static_cast<const FileWriteResponse *>(response()) : nullptr;
  }
  const FileSELinuxGetLabelResponse *response_as_FileSELinuxGetLabelResponse() const {
    return response_type() == ResponseType_FileSELinuxGetLabelResponse ? static_cast<const FileSELinuxGetLabelResponse *>(response()) : nullptr;
  }
  const FileSELinuxSetLabelResponse *response_as_FileSELinuxSetLabelResponse() const {
    return response_type() == ResponseType_FileSELinuxSetLabelResponse ? static_cast<const FileSELinuxSetLabelResponse *>(response()) : nullptr;
  }
  const PathChmodResponse *response_as_PathChmodResponse() const {
    return response_type() == ResponseType_PathChmodResponse ? static_cast<const PathChmodResponse *>(response()) : nullptr;
  }
  const PathCopyResponse *response_as_PathCopyResponse() const {
    return response_type() == ResponseType_PathCopyResponse ? static_cast<const PathCopyResponse *>(response()) : nullptr;
  }
  const PathSELinuxGetLabelResponse *response_as_PathSELinuxGetLabelResponse() const {
    return response_type() == ResponseType_PathSELinuxGetLabelResponse ? static_cast<const PathSELinuxGetLabelResponse *>(response()) : nullptr;
  }
  const PathSELinuxSetLabelResponse *response_as_PathSELinuxSetLabelResponse() const {
    return response_type() == ResponseType_PathSELinuxSetLabelResponse ? static_cast<const PathSELinuxSetLabelResponse *>(response()) : nullptr;
  }
  const PathGetDirectorySizeResponse *response_as_PathGetDirectorySizeResponse() const {
    return response_type() == ResponseType_PathGetDirectorySizeResponse ? static_cast<const PathGetDirectorySizeResponse *>(response()) : nullptr;
  }
  const MbGetVersionResponse *response_as_MbGetVersionResponse() const {
    return response_type() == ResponseType_MbGetVersionResponse ? static_cast<const MbGetVersionResponse *>(response()) : nullptr;
  }
  const MbGetInstalledRomsResponse *response_as_MbGetInstalledRomsResponse() const {
    return response_type() == ResponseType_MbGetInstalledRomsResponse ? static_cast<const MbGetInstalledRomsResponse *>(response()) : nullptr;
  }
  const MbGetBootedRomIdResponse *response_as_MbGetBootedRomIdResponse() const {
    return response_type() == ResponseType_MbGetBootedRomIdResponse ? static_cast<const MbGetBootedRomIdResponse *>(response()) : nullptr;
  }
  const MbSwitchRomResponse *response_as_MbSwitchRomResponse() const {
    return response_type() == ResponseType_MbSwitchRomResponse ? static_cast<const MbSwitchRomResponse *>(response()) : nullptr;
  }
  const MbSetKernelResponse *response_as_MbSetKernelResponse() const {
    return response_type() == ResponseType_MbSetKernelResponse ? static_cast<const MbSetKernelResponse *>(response()) : nullptr;
  }
  const MbWipeRomResponse *response_as_MbWipeRomResponse() const {
    return response_type() == ResponseType_MbWipeRomResponse ? static_cast<const MbWipeRomResponse *>(response()) : nullptr;
  }
  const MbGetPackagesCountResponse *response_as_MbGetPackagesCountResponse() const {
    return response_type() == ResponseType_MbGetPackagesCountResponse ? static_cast<const MbGetPackagesCountResponse *>(response()) : nullptr;
  }
  const RebootResponse *response_as_RebootResponse() const {
    return response_type() == ResponseType_RebootResponse ? static_cast<const RebootResponse *>(response()) : nullptr;
  }
  const SignedExecOutputResponse *response_as_SignedExecOutputResponse() const {
    return response_type() == ResponseType_SignedExecOutputResponse ? static_cast<const SignedExecOutputResponse *>(response()) : nullptr;
  }
  const SignedExecResponse *response_as_SignedExecResponse() const {
    return response_type() == ResponseType_SignedExecResponse ? static_cast<const SignedExecResponse *>(response()) : nullptr;
  }
  const ShutdownResponse *response_as_ShutdownResponse() const {
    return response_type() == ResponseType_ShutdownResponse ? static_cast<const ShutdownResponse *>(response()) : nullptr;
  }
  const PathDeleteResponse *response_as_PathDeleteResponse() const {
    return response_type() == ResponseType_PathDeleteResponse ? static_cast<const PathDeleteResponse *>(response()) : nullptr;
  }
  const PathMkdirResponse *response_as_PathMkdirResponse() const {
    return response_type() == ResponseType_PathMkdirResponse ? static_cast<const PathMkdirResponse *>(response()) : nullptr;
  }
  const CryptoDecryptResponse *response_as_CryptoDecryptResponse() const {
    return response_type() == ResponseType_CryptoDecryptResponse ? static_cast<const CryptoDecryptResponse *>(response()) : nullptr;
  }
  const CryptoGetPwTypeResponse *response_as_CryptoGetPwTypeResponse() const {
    return response_type() == ResponseType_CryptoGetPwTypeResponse ? static_cast<const CryptoGetPwTypeResponse *>(response()) : nullptr;
  }
  const PathReadlinkResponse *response_as_PathReadlinkResponse() const {
    return response_type() == ResponseType_PathReadlinkResponse ? static_cast<const PathReadlinkResponse *>(response()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           VerifyResponseType(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Invalid *Response::response_as<Invalid>() const {
  return response_as_Invalid();
}

template<> inline const Unsupported *Response::response_as<Unsupported>() const {
  return response_as_Unsupported();
}

template<> inline const FileChmodResponse *Response::response_as<FileChmodResponse>() const {
  return response_as_FileChmodResponse();
}

template<> inline const FileCloseResponse *Response::response_as<FileCloseResponse>() const {
  return response_as_FileCloseResponse();
}

template<> inline const FileOpenResponse *Response::response_as<FileOpenResponse>() const {
  return response_as_FileOpenResponse();
}

template<> inline const FileReadResponse *Response::response_as<FileReadResponse>() const {
  return response_as_FileReadResponse();
}

template<> inline const FileSeekResponse *Response::response_as<FileSeekResponse>() const {
  return response_as_FileSeekResponse();
}

template<> inline const FileStatResponse *Response::response_as<FileStatResponse>() const {
  return response_as_FileStatResponse();
}

template<> inline const FileWriteResponse *Response::response_as<FileWriteResponse>() const {
  return response_as_FileWriteResponse();
}

template<> inline const FileSELinuxGetLabelResponse *Response::response_as<FileSELinuxGetLabelResponse>() const {
  return response_as_FileSELinuxGetLabelResponse();
}

template<> inline const FileSELinuxSetLabelResponse *Response::response_as<FileSELinuxSetLabelResponse>() const {
  return response_as_FileSELinuxSetLabelResponse();
}

template<> inline const PathChmodResponse *Response::response_as<PathChmodResponse>() const {
  return response_as_PathChmodResponse();
}

template<> inline const PathCopyResponse *Response::response_as<PathCopyResponse>() const {
  return response_as_PathCopyResponse();
}

template<> inline const PathSELinuxGetLabelResponse *Response::response_as<PathSELinuxGetLabelResponse>() const {
  return response_as_PathSELinuxGetLabelResponse();
}

template<> inline const PathSELinuxSetLabelResponse *Response::response_as<PathSELinuxSetLabelResponse>() const {
  return response_as_PathSELinuxSetLabelResponse();
}

template<> inline const PathGetDirectorySizeResponse *Response::response_as<PathGetDirectorySizeResponse>() const {
  return response_as_PathGetDirectorySizeResponse();
}

template<> inline const MbGetVersionResponse *Response::response_as<MbGetVersionResponse>() const {
  return response_as_MbGetVersionResponse();
}

template<> inline const MbGetInstalledRomsResponse *Response::response_as<MbGetInstalledRomsResponse>() const {
  return response_as_MbGetInstalledRomsResponse();
}

template<> inline const MbGetBootedRomIdResponse *Response::response_as<MbGetBootedRomIdResponse>() const {
  return response_as_MbGetBootedRomIdResponse();
}

template<> inline const MbSwitchRomResponse *Response::response_as<MbSwitchRomResponse>() const {
  return response_as_MbSwitchRomResponse();
}

template<> inline const MbSetKernelResponse *Response::response_as<MbSetKernelResponse>() const {
  return response_as_MbSetKernelResponse();
}

template<> inline const MbWipeRomResponse *Response::response_as<MbWipeRomResponse>() const {
  return response_as_MbWipeRomResponse();
}

template<> inline const MbGetPackagesCountResponse *Response::response_as<MbGetPackagesCountResponse>() const {
  return response_as_MbGetPackagesCountResponse();
}

template<> inline const RebootResponse *Response::response_as<RebootResponse>() const {
  return response_as_RebootResponse();
}

template<> inline const SignedExecOutputResponse *Response::response_as<SignedExecOutputResponse>() const {
  return response_as_SignedExecOutputResponse();
}

template<> inline const SignedExecResponse *Response::response_as<SignedExecResponse>() const {
  return response_as_SignedExecResponse();
}

template<> inline const ShutdownResponse *Response::response_as<ShutdownResponse>() const {
  return response_as_ShutdownResponse();
}

template<> inline const PathDeleteResponse *Response::response_as<PathDeleteResponse>() const {
  return response_as_PathDeleteResponse();
}

template<> inline const PathMkdirResponse *Response::response_as<PathMkdirResponse>() const {
  return response_as_PathMkdirResponse();
}

template<> inline const CryptoDecryptResponse *Response::response_as<CryptoDecryptResponse>() const {
  return response_as_CryptoDecryptResponse();
}

template<> inline const CryptoGetPwTypeResponse *Response::response_as<CryptoGetPwTypeResponse>() const {
  return response_as_CryptoGetPwTypeResponse();
}

template<> inline const PathReadlinkResponse *Response::response_as<PathReadlinkResponse>() const {
  return response_as_PathReadlinkResponse();
}

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response_type(ResponseType response_type) {
    fbb_.AddElement<uint8_t>(Response::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(flatbuffers::Offset<void> response) {
    fbb_.AddOffset(Response::VT_RESPONSE, response);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ResponseType response_type = ResponseType_NONE,
    flatbuffers::Offset<void> response = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

inline bool VerifyResponseType(flatbuffers::Verifier &verifier, const void *obj, ResponseType type) {
  switch (type) {
    case ResponseType_NONE: {
      return true;
    }
    case ResponseType_Invalid: {
      auto ptr = reinterpret_cast<const Invalid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_Unsupported: {
      auto ptr = reinterpret_cast<const Unsupported *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileChmodResponse: {
      auto ptr = reinterpret_cast<const FileChmodResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileCloseResponse: {
      auto ptr = reinterpret_cast<const FileCloseResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileOpenResponse: {
      auto ptr = reinterpret_cast<const FileOpenResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileReadResponse: {
      auto ptr = reinterpret_cast<const FileReadResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileSeekResponse: {
      auto ptr = reinterpret_cast<const FileSeekResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileStatResponse: {
      auto ptr = reinterpret_cast<const FileStatResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileWriteResponse: {
      auto ptr = reinterpret_cast<const FileWriteResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileSELinuxGetLabelResponse: {
      auto ptr = reinterpret_cast<const FileSELinuxGetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileSELinuxSetLabelResponse: {
      auto ptr = reinterpret_cast<const FileSELinuxSetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathChmodResponse: {
      auto ptr = reinterpret_cast<const PathChmodResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathCopyResponse: {
      auto ptr = reinterpret_cast<const PathCopyResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathSELinuxGetLabelResponse: {
      auto ptr = reinterpret_cast<const PathSELinuxGetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathSELinuxSetLabelResponse: {
      auto ptr = reinterpret_cast<const PathSELinuxSetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathGetDirectorySizeResponse: {
      auto ptr = reinterpret_cast<const PathGetDirectorySizeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetVersionResponse: {
      auto ptr = reinterpret_cast<const MbGetVersionResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetInstalledRomsResponse: {
      auto ptr = reinterpret_cast<const MbGetInstalledRomsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetBootedRomIdResponse: {
      auto ptr = reinterpret_cast<const MbGetBootedRomIdResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbSwitchRomResponse: {
      auto ptr = reinterpret_cast<const MbSwitchRomResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbSetKernelResponse: {
      auto ptr = reinterpret_cast<const MbSetKernelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbWipeRomResponse: {
      auto ptr = reinterpret_cast<const MbWipeRomResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetPackagesCountResponse: {
      auto ptr = reinterpret_cast<const MbGetPackagesCountResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_RebootResponse: {
      auto ptr = reinterpret_cast<const RebootResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_SignedExecOutputResponse: {
      auto ptr = reinterpret_cast<const SignedExecOutputResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_SignedExecResponse: {
      auto ptr = reinterpret_cast<const SignedExecResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_ShutdownResponse: {
      auto ptr = reinterpret_cast<const ShutdownResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathDeleteResponse: {
      auto ptr = reinterpret_cast<const PathDeleteResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathMkdirResponse: {
      auto ptr = reinterpret_cast<const PathMkdirResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_CryptoDecryptResponse: {
      auto ptr = reinterpret_cast<const CryptoDecryptResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_CryptoGetPwTypeResponse: {
      auto ptr = reinterpret_cast<const CryptoGetPwTypeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathReadlinkResponse: {
      auto ptr = reinterpret_cast<const PathReadlinkResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResponseTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseType(
        verifier,  values->Get(i), types->GetEnum<ResponseType>(i))) {
      return false;
    }
  }
  return true;
}

inline const mbtool::daemon::v3::Response *GetResponse(const void *buf) {
  return flatbuffers::GetRoot<mbtool::daemon::v3::Response>(buf);
}

inline bool VerifyResponseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mbtool::daemon::v3::Response>(nullptr);
}

inline void FinishResponseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mbtool::daemon::v3::Response> root) {
  fbb.Finish(root);
}

}  // namespace v3
}  // namespace daemon
}  // namespace mbtool

#endif  // FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_
