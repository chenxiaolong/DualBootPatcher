// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MBSWITCHROM_MBTOOL_DAEMON_V3_H_
#define FLATBUFFERS_GENERATED_MBSWITCHROM_MBTOOL_DAEMON_V3_H_

#include "flatbuffers/flatbuffers.h"

namespace mbtool {
namespace daemon {
namespace v3 {

struct MbSwitchRomError;

struct MbSwitchRomRequest;

struct MbSwitchRomResponse;

enum MbSwitchRomResult {
  MbSwitchRomResult_SUCCEEDED = 0,
  MbSwitchRomResult_FAILED = 1,
  MbSwitchRomResult_CHECKSUM_NOT_FOUND = 2,
  MbSwitchRomResult_CHECKSUM_INVALID = 3,
  MbSwitchRomResult_MIN = MbSwitchRomResult_SUCCEEDED,
  MbSwitchRomResult_MAX = MbSwitchRomResult_CHECKSUM_INVALID
};

inline MbSwitchRomResult (&EnumValuesMbSwitchRomResult())[4] {
  static MbSwitchRomResult values[] = {
    MbSwitchRomResult_SUCCEEDED,
    MbSwitchRomResult_FAILED,
    MbSwitchRomResult_CHECKSUM_NOT_FOUND,
    MbSwitchRomResult_CHECKSUM_INVALID
  };
  return values;
}

inline const char **EnumNamesMbSwitchRomResult() {
  static const char *names[] = {
    "SUCCEEDED",
    "FAILED",
    "CHECKSUM_NOT_FOUND",
    "CHECKSUM_INVALID",
    nullptr
  };
  return names;
}

inline const char *EnumNameMbSwitchRomResult(MbSwitchRomResult e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMbSwitchRomResult()[index];
}

struct MbSwitchRomError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MbSwitchRomErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MbSwitchRomErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MbSwitchRomErrorBuilder &operator=(const MbSwitchRomErrorBuilder &);
  flatbuffers::Offset<MbSwitchRomError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MbSwitchRomError>(end);
    return o;
  }
};

inline flatbuffers::Offset<MbSwitchRomError> CreateMbSwitchRomError(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MbSwitchRomErrorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MbSwitchRomRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROM_ID = 4,
    VT_BOOT_BLOCKDEV = 6,
    VT_BLOCKDEV_BASE_DIRS = 8,
    VT_FORCE_UPDATE_CHECKSUMS = 10
  };
  const flatbuffers::String *rom_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROM_ID);
  }
  const flatbuffers::String *boot_blockdev() const {
    return GetPointer<const flatbuffers::String *>(VT_BOOT_BLOCKDEV);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *blockdev_base_dirs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_BLOCKDEV_BASE_DIRS);
  }
  bool force_update_checksums() const {
    return GetField<uint8_t>(VT_FORCE_UPDATE_CHECKSUMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROM_ID) &&
           verifier.Verify(rom_id()) &&
           VerifyOffset(verifier, VT_BOOT_BLOCKDEV) &&
           verifier.Verify(boot_blockdev()) &&
           VerifyOffset(verifier, VT_BLOCKDEV_BASE_DIRS) &&
           verifier.Verify(blockdev_base_dirs()) &&
           verifier.VerifyVectorOfStrings(blockdev_base_dirs()) &&
           VerifyField<uint8_t>(verifier, VT_FORCE_UPDATE_CHECKSUMS) &&
           verifier.EndTable();
  }
};

struct MbSwitchRomRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rom_id(flatbuffers::Offset<flatbuffers::String> rom_id) {
    fbb_.AddOffset(MbSwitchRomRequest::VT_ROM_ID, rom_id);
  }
  void add_boot_blockdev(flatbuffers::Offset<flatbuffers::String> boot_blockdev) {
    fbb_.AddOffset(MbSwitchRomRequest::VT_BOOT_BLOCKDEV, boot_blockdev);
  }
  void add_blockdev_base_dirs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> blockdev_base_dirs) {
    fbb_.AddOffset(MbSwitchRomRequest::VT_BLOCKDEV_BASE_DIRS, blockdev_base_dirs);
  }
  void add_force_update_checksums(bool force_update_checksums) {
    fbb_.AddElement<uint8_t>(MbSwitchRomRequest::VT_FORCE_UPDATE_CHECKSUMS, static_cast<uint8_t>(force_update_checksums), 0);
  }
  explicit MbSwitchRomRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MbSwitchRomRequestBuilder &operator=(const MbSwitchRomRequestBuilder &);
  flatbuffers::Offset<MbSwitchRomRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MbSwitchRomRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MbSwitchRomRequest> CreateMbSwitchRomRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> rom_id = 0,
    flatbuffers::Offset<flatbuffers::String> boot_blockdev = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> blockdev_base_dirs = 0,
    bool force_update_checksums = false) {
  MbSwitchRomRequestBuilder builder_(_fbb);
  builder_.add_blockdev_base_dirs(blockdev_base_dirs);
  builder_.add_boot_blockdev(boot_blockdev);
  builder_.add_rom_id(rom_id);
  builder_.add_force_update_checksums(force_update_checksums);
  return builder_.Finish();
}

inline flatbuffers::Offset<MbSwitchRomRequest> CreateMbSwitchRomRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *rom_id = nullptr,
    const char *boot_blockdev = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *blockdev_base_dirs = nullptr,
    bool force_update_checksums = false) {
  return mbtool::daemon::v3::CreateMbSwitchRomRequest(
      _fbb,
      rom_id ? _fbb.CreateString(rom_id) : 0,
      boot_blockdev ? _fbb.CreateString(boot_blockdev) : 0,
      blockdev_base_dirs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*blockdev_base_dirs) : 0,
      force_update_checksums);
}

struct MbSwitchRomResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESS = 4,
    VT_RESULT = 6,
    VT_ERROR = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  MbSwitchRomResult result() const {
    return static_cast<MbSwitchRomResult>(GetField<int16_t>(VT_RESULT, 0));
  }
  const MbSwitchRomError *error() const {
    return GetPointer<const MbSwitchRomError *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<int16_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
};

struct MbSwitchRomResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(MbSwitchRomResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_result(MbSwitchRomResult result) {
    fbb_.AddElement<int16_t>(MbSwitchRomResponse::VT_RESULT, static_cast<int16_t>(result), 0);
  }
  void add_error(flatbuffers::Offset<MbSwitchRomError> error) {
    fbb_.AddOffset(MbSwitchRomResponse::VT_ERROR, error);
  }
  explicit MbSwitchRomResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MbSwitchRomResponseBuilder &operator=(const MbSwitchRomResponseBuilder &);
  flatbuffers::Offset<MbSwitchRomResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MbSwitchRomResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MbSwitchRomResponse> CreateMbSwitchRomResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    MbSwitchRomResult result = MbSwitchRomResult_SUCCEEDED,
    flatbuffers::Offset<MbSwitchRomError> error = 0) {
  MbSwitchRomResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_result(result);
  builder_.add_success(success);
  return builder_.Finish();
}

}  // namespace v3
}  // namespace daemon
}  // namespace mbtool

#endif  // FLATBUFFERS_GENERATED_MBSWITCHROM_MBTOOL_DAEMON_V3_H_
